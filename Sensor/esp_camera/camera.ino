#include "arduino_secrets.h"
/* 
  Sketch generated by the Arduino IoT Cloud Thing  
*/

// arduino_secrets.h
#ifndef ARDUINO_SECRETS_H
#define ARDUINO_SECRETS_H
#define SECRET_SSID          
#define SECRET_OPTIONAL_PASS 
#define SECRET_DEVICE_KEY    "FtuBzak!Cs?PIBq0aias0@L8U"
#endif

#include "thingProperties.h"   
#include <Seeed_Arduino_SSCMA.h>
#include "driver/ledc.h"
#include <esp_task_wdt.h> // 看门狗定时器

// —— SSCMA 手势识别相关 —— 
SSCMA AI;
static const char* LABELS[] = { "Paper", "Rock", "Scissors" };

// —— 防抖机制 —— 
unsigned long lastGestureTime = 0;     // 上次发送手势的时间
const unsigned long DEBOUNCE_TIME = 5000; // 5秒防抖时间
int lastDetectedGesture = -1;          // 上次检测到的手势（初始为无效值）

// 看门狗定时器配置
const int WDT_TIMEOUT = 10; // 10秒看门狗超时

void printMemoryInfo() {
  Serial.print("Free Heap: ");
  Serial.print(esp_get_free_heap_size());
  Serial.print(" bytes, Min Free Heap: ");
  Serial.print(esp_get_minimum_free_heap_size());
  Serial.println(" bytes");
}

void setup() {
  // 初始化看门狗
  esp_task_wdt_init(WDT_TIMEOUT, true); // 启用恐慌模式（重启）
  esp_task_wdt_add(NULL); // 添加当前任务到看门狗
  
  Serial.begin(115200);
  delay(1000); // 等待串口稳定
  
  Serial.println(">>> 启动设备...");
  printMemoryInfo();

  // 初始化AI库（带错误处理）
  Serial.println("初始化AI库...");
  if (!AI.begin()) {
    Serial.println("AI初始化失败! 重启设备...");
    delay(2000);
    ESP.restart();
  }
  Serial.println("AI库初始化成功");
  printMemoryInfo();

  // 初始化云连接
  Serial.println("初始化云连接...");
  initProperties();
  
  // 配置WiFi
  WiFi.mode(WIFI_STA);
  WiFi.setAutoReconnect(true);
  WiFi.persistent(true);
  
  Serial.print("连接WiFi: ");
  Serial.println(SECRET_SSID);
  WiFi.begin(SECRET_SSID, SECRET_OPTIONAL_PASS);
  
  int wifiRetry = 0;
  while (WiFi.status() != WL_CONNECTED && wifiRetry < 20) {
    delay(500);
    Serial.print(".");
    wifiRetry++;
    esp_task_wdt_reset(); // 重置看门狗
  }
  
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("\nWiFi连接失败! 重启中...");
    delay(2000);
    ESP.restart();
  }
  
  Serial.println("\nWiFi已连接!");
  Serial.print("IP地址: ");
  Serial.println(WiFi.localIP());
  printMemoryInfo();

  // 连接Arduino Cloud
  Serial.println("连接Arduino Cloud...");
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  
  int cloudRetry = 0;
  while (!ArduinoCloud.connected() && cloudRetry < 15) {
    ArduinoCloud.update();
    delay(500);
    Serial.print(".");
    cloudRetry++;
    esp_task_wdt_reset(); // 重置看门狗
  }
  
  if (!ArduinoCloud.connected()) {
    Serial.println("\nArduino Cloud连接失败! 重启中...");
    delay(2000);
    ESP.restart();
  }
  
  Serial.println("\n>>> 设备已连接云端");
  Serial.println(">>> 防抖时间: 5秒");
  printMemoryInfo();
  
  // 设置初始手势值
  gesture = -1;
  
  Serial.println(">>> 进入主循环");
}

void loop() {
  // 重置看门狗
  esp_task_wdt_reset();
  
  // 更新云状态
  ArduinoCloud.update();
  
  // 检查内存状态
  static unsigned long lastMemCheck = 0;
  if (millis() - lastMemCheck > 5000) {
    printMemoryInfo();
    lastMemCheck = millis();
  }

  // ----------------------------
  // SSCMA 推理，读取手势（带5秒防抖）
  // ----------------------------
  if (!AI.invoke()) {
    auto &boxes = AI.boxes();
    if (!boxes.empty()) {
      // 选出置信度最高的那个框
      int best = 0;
      for (int i = 1; i < boxes.size(); i++) {
        if (boxes[i].score > boxes[best].score) {
          best = i;
        }
      }

      int cls = boxes[best].target;  // 0=Paper, 1=Rock, 2=Scissors
      unsigned long currentTime = millis();
      
      // 防抖逻辑：只有在5秒内没有发送过手势时才更新
      if (currentTime - lastGestureTime >= DEBOUNCE_TIME) {
        gesture = cls;  // 更新云端变量
        lastGestureTime = currentTime;
        lastDetectedGesture = cls;
        
        Serial.print(">>> 发送手势: ");
        Serial.print(LABELS[cls]);
        Serial.print(" (");
        Serial.print(cls);
        Serial.println(")");
      }
      // 检测到新手势但仍在防抖期内
      else if (cls != lastDetectedGesture) {
        Serial.print(">>> 检测到手势变化: ");
        Serial.print(LABELS[cls]);
        Serial.print(" -> 但仍在防抖期内 (剩余 ");
        Serial.print((DEBOUNCE_TIME - (currentTime - lastGestureTime)) / 1000);
        Serial.println("秒)");
      }
    }
  } else {
    Serial.println("AI推理失败");
  }

  delay(200);  // 降低推理频率，节省资源
}